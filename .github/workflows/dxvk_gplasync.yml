name: Build DXVK gplasync rev4

on:
  workflow_dispatch:
  schedule:
    - cron: "0 18 * * *"

permissions:
  contents: write

defaults:
  run:
    shell: 'bash --noprofile --norc -Eeuo pipefail {0}'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  guard:
    name: Check Update (detect new DXVK tag + GPLAsync release map)
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      build: ${{ steps.decide.outputs.build }}
    env:
      GH_TOKEN: ${{ github.token }}
      REPO: ${{ github.repository }}
      RELEASE_TAG: DXVK-GPLASYNC
      GPLASYNC_BASE_URL: https://gitlab.com/Ph42oN/dxvk-gplasync/-/raw/main/patches
      DXVK_REPO: doitsujin/dxvk
      GITLAB_PROJECT: Ph42oN/dxvk-gplasync
    steps:
      - name: Install jq, curl (minimal)
        run: |
          sudo apt-get -yq update
          sudo apt-get -yq install --no-install-recommends jq curl ca-certificates

# ------------------------------------------------------------------------------ #

      - name: Collect already-published (base,rev)
        id: have
        run: |
          set -Eeuo pipefail
          API="https://api.github.com"
          auth=(-H "Authorization: Bearer ${GH_TOKEN}")
          ver=(-H "Accept: application/vnd.github+json")
          HTTP="$(curl -s -o /tmp/rel.json -w '%{http_code}' "${auth[@]}" "${ver[@]}" \
                  "$API/repos/${REPO}/releases/tags/${RELEASE_TAG}" || true)"
          if [ "$HTTP" = "200" ]; then
            jq -r '.assets[].name' /tmp/rel.json \
              | sed -n -E 's/^dxvk-gplasync-([0-9]+\.[0-9]+(\.[0-9]+)?)-([1-9][0-9]*)\.wcp$/\1 \3/p' \
              | LC_ALL=C sort -V > /tmp/exist.txt
          else
            : > /tmp/exist.txt
          fi
          echo "Existing base/rev:"; cat /tmp/exist.txt || true

      - name: Build GPLAsync release map (from GitLab Releases)
        id: relmap
        env:
          GITLAB_PROJECT: ${{ env.GITLAB_PROJECT }}
        run: |
          set -Eeuo pipefail
        
          # URL-encode project path for GitLab API (no heredoc)
          enc="$(python3 -c 'import urllib.parse,os;print(urllib.parse.quote(os.environ["GITLAB_PROJECT"], safe=""))')"
          GL_API="https://gitlab.com/api/v4/projects/${enc}"
        
          : > /tmp/gl_rel.jsonl
          page=1
          while :; do
            curl -fsSL -D /tmp/h "${GL_API}/releases?per_page=100&page=${page}" -o /tmp/p.json || true
            jq -c '.[]' /tmp/p.json >> /tmp/gl_rel.jsonl || true
            next=$(awk 'tolower($1)=="x-next-page:"{print $2}' /tmp/h | tr -d '\r')
            [[ -z "${next:-}" || "${next}" == "0" ]] && break
            page="${next}"
          done

          { cat /tmp/gl_rel.jsonl | jq -r '[.tag_name,.name] | map(select(.!=null)) | .[]'; } \
            | grep -Eio 'v?[0-9]+\.[0-9]+(\.[0-9]+)?-[1-9]' || true \
            | sed -E 's/^[Vv]//' \
            | sort -u \
            | awk -F- '{print $1" "$2}' \
            | awk '{b=$1; r=$2+0; if(r>0 && r<=9 && r>max[b]) max[b]=r} END{for(b in max) print b, max[b]}' \
            | LC_ALL=C sort -V > /tmp/relmax.txt || true
        
          [[ -f /tmp/relmax.txt ]] || : > /tmp/relmax.txt
        
          echo "Release map (base -> max rev):"
          cat /tmp/relmax.txt || true

      - name: Detect any missing candidate (use release map; prefer exact base, then major.minor)
        id: detect
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
          DXVK_REPO: ${{ env.DXVK_REPO }}
        run: |
          set -Eeuo pipefail
          API="https://api.github.com"
          auth=(-H "Authorization: Bearer ${GH_TOKEN}")
          ver=(-H "Accept: application/vnd.github+json")

          # Fetch DXVK tags and keep semantic v* >= 2.3.1
          curl -fsSL "${auth[@]}" "${ver[@]}" "$API/repos/${DXVK_REPO}/tags?per_page=100" \
            | jq -r '.[].name' \
            | grep -E '^v[0-9]+\.[0-9]+(\.[0-9]+)?$' \
            | LC_ALL=C sort -V > /tmp/tags.txt

          # ìµœì‹ ë¶€í„° í™•ì¸
          tac /tmp/tags.txt > /tmp/tags.desc.txt

          awk '
            function cmp(a,b,  i,A,B){split(a,A,".");split(b,B,".");
              for(i=1;i<=3;i++){if((A[i]+0)<(B[i]+0))return -1;if((A[i]+0)>(B[i]+0))return 1} return 0}
            { base=substr($0,2); if (cmp(base,"2.3.1")>=0) print $0 }
          ' /tmp/tags.desc.txt > /tmp/candidates.txt

          : > /tmp/missing.flag

          while read -r tag; do
            [ -n "$tag" ] || continue
            base="${tag#v}"             # 2.7 | 2.7.0 | 2.6.2
            IFS=. read -r A B C <<<"$base"

            # ë² ì´ìŠ¤ ì •ê·œí™” í›„ë³´: 2.7 <-> 2.7.0, 2.6.2 -> 2.6
            cand_bases=("$base")
            [[ "$base" =~ ^[0-9]+\.[0-9]+$    ]] && cand_bases+=("${base}.0")
            [[ "$base" =~ ^[0-9]+\.[0-9]+\.0$ ]] && cand_bases+=("${A}.${B}")
            [[ -n "${C:-}" ]] && cand_bases+=("${A}.${B}")

            echo "::notice::relmap (head)"; sed -n '1,20p' /tmp/relmax.txt || true
            echo "::notice::exist (head)"; sed -n '1,20p' /tmp/exist.txt || true

            rev=""
            patch_base=""
            for b in "${cand_bases[@]}"; do
              r=$(awk -v b="$b" '$1==b{print $2}' /tmp/relmax.txt | head -n1)
              if [[ -n "$r" ]]; then
                rev="$r"; patch_base="$b"; break
              fi
            done

            # ë¦´ë¦¬ìŠ¤ ë§µì— ì—†ìœ¼ë©´ ì´ íƒœê·¸ ìŠ¤í‚µ
            [[ -z "$rev" ]] && continue

            # ì´ë¯¸ ì˜¬ë¦° ì¡°í•©ì¸ì§€: í•œ ì¤„ ì •í™• ì¼ì¹˜ë¡œë§Œ ì¸ì •
            if ! grep -Fxq "${base} ${rev}" /tmp/exist.txt; then
              echo "Missing: ${base}-${rev} (patch_base: ${patch_base})"
              echo yes > /tmp/missing.flag
              break
            fi
          done < /tmp/candidates.txt

          if [ "$(cat /tmp/missing.flag 2>/dev/null)" = yes ]; then
            echo "missing=true" >> "$GITHUB_OUTPUT"
          else
            echo "missing=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Decide build
        id: decide
        run: |
          set -Eeuo pipefail
          if [ "${{ steps.detect.outputs.missing }}" = "true" ]; then
            echo "build=true"  >> "$GITHUB_OUTPUT"
          else
            echo "build=false" >> "$GITHUB_OUTPUT"
          fi

# ------------------------------------------------------------------------------ #

  build-and-release:
    name: Build & release missing versions
    runs-on: ubuntu-24.04
    needs: guard
    if: needs.guard.outputs.build == 'true'
    env:
      DXVK_REPO: doitsujin/dxvk
      GPLASYNC_BASE_URL: https://gitlab.com/Ph42oN/dxvk-gplasync/-/raw/main/patches
      TOOLCHAIN_DIR: /opt/llvm-mingw
      RELEASE_TAG: DXVK-GPLASYNC
      GH_TOKEN: ${{ github.token }}
      LLVM_MINGW_TAG: ${{ vars.LLVM_MINGW_TAG || '20250613' }}
      GITLAB_PROJECT: Ph42oN/dxvk-gplasync
    steps:
      - name: Install host tooling (lean set; no cache)
        run: |
          sudo apt-get -yq update
          sudo apt-get -yq install --no-install-recommends \
            curl xz-utils jq ca-certificates \
            git meson ninja-build glslang-tools pkg-config \
            build-essential python3 zstd gh file

      - name: Ensure glslang (--vn)
        run: |
          set -Eeuo pipefail
          cat > /tmp/min.comp <<'GLSL'
          #version 450
          void main() {}
          GLSL
          have() { command -v "$1" >/dev/null 2>&1 || return 1; "$1" --quiet --target-env vulkan1.3 --vn testvar -o /tmp/min.h /tmp/min.comp; }
          if have glslang; then :
          elif have glslangValidator; then
            BIN="$HOME/.local/bin"; mkdir -p "$BIN"
            ln -sf "$(command -v glslangValidator)" "$BIN/glslang"
            echo "$BIN" >> "$GITHUB_PATH"
          else
            echo "::error::No glslang/glslangValidator with working --vn"; exit 1
          fi

      - name: Download pinned llvm-mingw (UCRT)
        id: llvm
        env:
          TAG: ${{ env.LLVM_MINGW_TAG }}
        run: |
          set -Eeuo pipefail
          API="https://api.github.com/repos/mstorsjo/llvm-mingw/releases/tags/${TAG}"
          json=$(curl -fsSL --retry 3 --retry-delay 2 -H "Authorization: Bearer $GH_TOKEN" "$API" || true)

          pick_url() {
            local json="$1"
            local url=""
            for dist in 22.04 20.04; do
              url=$(jq -r --arg dist "$dist" '
                .assets[]?
                | select(.name | endswith("ucrt-ubuntu-" + $dist + "-x86_64.tar.xz"))
                | .browser_download_url
              ' <<<"$json" | head -n1 || true)
              [[ -n "$url" && "$url" != "null" ]] && { echo "$url"; return 0; }
            done
            return 1
          }

          url="$(pick_url "$json" || true)"
          if [[ -z "${url:-}" ]]; then
            echo "::warning::Pinned llvm-mingw ${TAG} asset not found; falling back to latest"
            json=$(curl -fsSL --retry 3 --retry-delay 2 -H "Authorization: Bearer $GH_TOKEN" \
                   https://api.github.com/repos/mstorsjo/llvm-mingw/releases/latest || true)
            url="$(pick_url "$json" || true)"
          fi

          [[ -n "${url:-}" ]] || { echo "::error::llvm-mingw asset not found"; exit 1; }

          TOOLCHAIN_DIR=/opt/llvm-mingw
          sudo mkdir -p "$TOOLCHAIN_DIR"
          curl -fL --retry 3 --retry-delay 2 -H "Authorization: Bearer $GH_TOKEN" \
               "$url" -o /tmp/llvm-mingw.tar.xz
          sudo tar -C "$TOOLCHAIN_DIR" --strip-components=1 -xJf /tmp/llvm-mingw.tar.xz
          echo "$TOOLCHAIN_DIR/bin" >> "$GITHUB_PATH"

      - name: Clone DXVK
        run: |
          set -Eeuo pipefail
          git clone --recurse-submodules https://github.com/${DXVK_REPO}.git src
          cd src && git fetch --tags --force

      - name: Configure git identity
        run: |
          git -C src config user.name "DXVK Builder"
          git -C src config user.email "builder@users.noreply.github.com"

      - name: Resolve versions & compute NEW to build (release-aware)
        env:
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ github.token }}
          GITLAB_PROJECT: ${{ env.GITLAB_PROJECT }}
        run: |
          set -Eeuo pipefail
          cd src
          git tag -l 'v*' \
            | { grep -E '^v[0-9]+\.[0-9]+(\.[0-9]+)?$' || true; } \
            | LC_ALL=C sort -V \
            | awk '
                function cmp(a,b,  i,A,B){split(a,A,".");split(b,B,".");
                  for(i=1;i<=3;i++){if((A[i]+0)<(B[i]+0))return -1;if((A[i]+0)>(B[i]+0))return 1}return 0}
                {ver=substr($0,2); if (cmp(ver,"2.3.1")>=0) print $0}
              ' > "${GITHUB_WORKSPACE}/versions.txt"

          : > "${GITHUB_WORKSPACE}/to_build.txt"

          EXIST="/tmp/exist.txt"; : > "$EXIST"
          if gh release view "${RELEASE_TAG}" --repo "${REPO}" >/dev/null 2>&1; then
            gh api repos/"${REPO}"/releases/tags/"${RELEASE_TAG}" \
              | jq -r '.assets[].name' \
              | sed -n -E 's/^dxvk-gplasync-([0-9]+\.[0-9]+(\.[0-9]+)?)\-([1-9])\.wcp$/\1 \3/p' \
              | LC_ALL=C sort -V > "$EXIST" || true
          fi

          # Build release map from GitLab (allow optional 'v' prefix in names)
          enc="$(python3 -c 'import urllib.parse,os;print(urllib.parse.quote(os.environ["GITLAB_PROJECT"], safe=""))')"
          GL_API="https://gitlab.com/api/v4/projects/${enc}"
          : > /tmp/gl_rel.jsonl
          page=1
          while :; do
            curl -fsSL -D /tmp/h "${GL_API}/releases?per_page=100&page=${page}" -o /tmp/p.json || true
            jq -c '.[]' /tmp/p.json >> /tmp/gl_rel.jsonl || true
            next=$(awk 'tolower($1)=="x-next-page:"{print $2}' /tmp/h | tr -d '\r')
            [[ -z "${next:-}" || "${next}" == "0" ]] && break
            page="${next}"
          done
          
          { cat /tmp/gl_rel.jsonl | jq -r '[.tag_name,.name] | map(select(.!=null)) | .[]'; } \
            | grep -Eio 'v?[0-9]+\.[0-9]+(\.[0-9]+)?-[1-9]' || true \
            | sed -E 's/^[Vv]//' \
            | sort -u \
            | awk -F- '{print $1" "$2}' \
            | awk '{b=$1; r=$2+0; if(r>0 && r<=9 && r>max[b]) max[b]=r} END{for(b in max) print b, max[b]}' \
            | LC_ALL=C sort -V > /tmp/relmax.txt || true

          while IFS= read -r tag; do
            [ -n "$tag" ] || continue
            base="${tag#v}"
            IFS=. read -r A B C <<<"$base"
            mm=""; [[ -n "${C:-}" ]] && mm="${A}.${B}"

            found_rev=""; patch_base=""
            r=$(awk -v b="$base" '$1==b{print $2}' /tmp/relmax.txt | head -n1)
            if [[ -n "$r" ]]; then
              found_rev="$r"; patch_base="$base"
            elif [[ -n "$mm" ]]; then
              r=$(awk -v b="$mm" '$1==b{print $2}' /tmp/relmax.txt | head -n1)
              if [[ -n "$r" ]]; then
                found_rev="$r"; patch_base="$mm"
              fi
            fi

            # If no patch exists per releases, skip this tag
            if [[ -z "$found_rev" ]]; then
              echo "::notice::No gplasync release for ${base}$( [[ -n "$mm" ]] && printf ' (or %s)' "$mm" ); skipping"
              continue
            fi

            # Skip if already built
            if grep -Fq "${base} ${found_rev}" "$EXIST"; then
              echo "Skip ${base}-${found_rev} (already built)"
              continue
            fi

            # Record work item: tag base rev patch_base
            echo "${tag} ${base} ${found_rev} ${patch_base}" >> "${GITHUB_WORKSPACE}/to_build.txt"
          done < "${GITHUB_WORKSPACE}/versions.txt"

          echo "To build (tag base rev patch_base):"
          cat "${GITHUB_WORKSPACE}/to_build.txt" || true

      - name: Build NEW versions
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
        run: |
          set -Eeuo pipefail
          OUT="${GITHUB_WORKSPACE}/out"; mkdir -p "$OUT"
          cd "${GITHUB_WORKSPACE}/src"

          LIST="${GITHUB_WORKSPACE}/to_build.txt"
          if [[ ! -f "$LIST" || ! -s "$LIST" ]]; then
            echo "No new versions to build."; exit 0; fi

          while read -r tag base rev patch_base; do
            echo "::group::Build ${tag} (gplasync rev ${rev}, patch_base ${patch_base})"
            git checkout -f "$tag"
            git submodule update --init --recursive --checkout

            CHANGED=0
            # patches --------------------------------------------------------------- #
            # Apply gplasync patch picked from Releases map
            url="${GPLASYNC_BASE_URL}/dxvk-gplasync-${patch_base}-${rev}.patch"
            curl -fL "$url" -o /tmp/gpl.patch
            git config user.name  ci
            git config user.email ci@local
            if git am -3 /tmp/gpl.patch; then :; else git am --abort || true; git apply -p1 --reject /tmp/gpl.patch; fi
            grep -q "enableAsync" src/dxvk/dxvk_options.h || { echo "::error::Patch not applied cleanly for ${base} (using ${patch_base}-${rev})"; git status -sb; exit 1; }

            # patches --------------------------------------------------------------- #
            # v2.5 UnmappedSubresource constexpr init issue -> safe cast
            TEX="src/d3d11/d3d11_texture.h"
            if [[ -f "$TEX" ]] && grep -qE '\bUnmappedSubresource\b' "$TEX"; then
              cp "$TEX" "${TEX}.bak"
              perl -0777 -pe \
                's/\bstatic\s+(?:const|constexpr)\s+D3D11_MAP\s+UnmappedSubresource\s*=\s*[^;]+;/inline static const D3D11_MAP UnmappedSubresource = static_cast<D3D11_MAP>(-1);/s' \
                -i "$TEX" && CHANGED=1
            fi
            
            # patches --------------------------------------------------------------- #
            # Newer mingw headers define _D3DDEVINFO_RESOURCEMANAGER -> drop DXVK duplicate if toolchain has it
            INC="src/d3d9/d3d9_include.h"
            TOOL_X64="/opt/llvm-mingw/x86_64-w64-mingw32/include/d3d9types.h"
            TOOL_X86="/opt/llvm-mingw/i686-w64-mingw32/include/d3d9types.h"
            if [[ -f "$INC" ]] && (grep -Fq "_D3DDEVINFO_RESOURCEMANAGER" "$TOOL_X64" || grep -Fq "_D3DDEVINFO_RESOURCEMANAGER" "$TOOL_X86"); then
              if grep -qE 'typedef\s+struct\s+_D3DDEVINFO_RESOURCEMANAGER\b' "$INC"; then
                cp "$INC" "${INC}.bak"
                perl -0777 -pe 's/typedef\s+struct\s+_D3DDEVINFO_RESOURCEMANAGER\b.*?}\s*D3DDEVINFO_RESOURCEMANAGER\b[^;]*;//s' -i "$INC" && CHANGED=1
              fi
            fi
            
            # patches --------------------------------------------------------------- #
            # Mismatched-tags warning: align forward decl to 'struct' (optional)
            MEM="src/dxvk/dxvk_memory.h"
            if [[ -f "$MEM" ]] \
               && grep -qE '^[[:space:]]*class[[:space:]]+DxvkMemoryChunk;' "$MEM" \
               && grep -qE '^[[:space:]]*struct[[:space:]]+DxvkMemoryChunk[[:space:]]*\{' "$MEM"; then
              cp "$MEM" "${MEM}.bak2"
              sed -E -i 's/^[[:space:]]*class[[:space:]]+DxvkMemoryChunk;/struct DxvkMemoryChunk;/' "$MEM" && CHANGED=1
            fi

            ver="${tag#v}"

            # Build using official script + cross files ----------------------------- #
            PKGDIR="${GITHUB_WORKSPACE}/pkg"
            mkdir -p "$PKGDIR"
            ./package-release.sh "$tag" "$PKGDIR" --no-package --dev-build

            # Collect DLLs
            mkdir -p "${GITHUB_WORKSPACE}/DXVK_WCP/system32" "${GITHUB_WORKSPACE}/DXVK_WCP/syswow64"
            cp -v "${PREFIX_X64}/bin/"*.dll  "${GITHUB_WORKSPACE}/DXVK_WCP/system32/" || true
            cp -v "${PREFIX_X86}/bin/"*.dll "${GITHUB_WORKSPACE}/DXVK_WCP/syswow64/" || true

            (cd "${GITHUB_WORKSPACE}/DXVK_WCP" && find system32 -maxdepth 1 -type f -name '*.dll' -printf '%f\n' | LC_ALL=C sort) > /tmp/x64.txt || true
            (cd "${GITHUB_WORKSPACE}/DXVK_WCP" && find syswow64 -maxdepth 1 -type f -name '*.dll' -printf '%f\n' | LC_ALL=C sort) > /tmp/x86.txt || true
            if [[ ! -s /tmp/x64.txt && ! -s /tmp/x86.txt ]]; then
              echo "::error::No DLLs discovered for ${base}-${rev}"; exit 1; fi

            jq -R -s 'split("\n") | map(select(length>0))' /tmp/x64.txt  > /tmp/x64.json
            jq -R -s 'split("\n") | map(select(length>0))' /tmp/x86.txt  > /tmp/x86.json

            DESC="DXVK gplasync build by Ari"
            jq -n \
              --arg VN "gplasync-${base}" \
              --argjson VC "${rev}" \
              --arg DESC "$DESC" \
              --arg SYS '${system32}/' \
              --arg WOW '${syswow64}/' \
              --slurpfile x64 /tmp/x64.json \
              --slurpfile x86 /tmp/x86.json \
              '
              ($x64[0] // []) as $A |
              ($x86[0] // []) as $B |
              {
                type: "DXVK",
                versionName: $VN,
                versionCode: $VC,
                description: $DESC,
                files: [
                  ($A[]? | {source: ("system32/"+.), target: ($SYS + .)}),
                  ($B[]? | {source: ("syswow64/"+.), target: ($WOW + .)})
                ]
              }' > "${GITHUB_WORKSPACE}/DXVK_WCP/profile.json"

            export SOURCE_DATE_EPOCH="$(git log -1 --format=%ct "$tag")"
            mkdir -p "${GITHUB_WORKSPACE}/out"
            tar -C "${GITHUB_WORKSPACE}/DXVK_WCP" --zstd --format=gnu --owner=0 --group=0 --numeric-owner \
              --sort=name \
              -cf "${GITHUB_WORKSPACE}/out/dxvk-gplasync-${base}-${rev}.wcp" profile.json system32 syswow64
            echo "::endgroup::"
          done < "${GITHUB_WORKSPACE}/to_build.txt"

      - name: Build release notes (minimal)
        run: |
          set -Eeuo pipefail
          NOTES="${GITHUB_WORKSPACE}/RELEASE_NOTES.md"
          printf 'ðŸ¤– Automated gplasync builds (2.3.1+)\n\n' > "$NOTES"
          if compgen -G "${GITHUB_WORKSPACE}/out/dxvk-gplasync-*.wcp" > /dev/null; then
            latest="$(ls -1 "${GITHUB_WORKSPACE}/out"/dxvk-gplasync-*.wcp | sed 's#.*/##' | LC_ALL=C sort -V | tail -n1)"
            cur="${latest#dxvk-gplasync-}"; cur="${cur%.wcp}"
            echo "Current: ${cur}" >> "$NOTES"
          fi
          cat "$NOTES"

      - name: Create/Update GitHub Release (DXVK-GPLASYNC) + upload WCPs
        env:
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -Eeuo pipefail
          NOTES="${GITHUB_WORKSPACE}/RELEASE_NOTES.md"
          RELEASE_TAG="DXVK-GPLASYNC"

          if ! gh release view "${RELEASE_TAG}" --repo "${REPO}" >/dev/null 2>&1; then
            gh release create "${RELEASE_TAG}" --repo "${REPO}" -t "${RELEASE_TAG}" -F "$NOTES"
          else
            gh release edit   "${RELEASE_TAG}" --repo "${REPO}" -t "${RELEASE_TAG}" -F "$NOTES"
          fi

          if compgen -G "${GITHUB_WORKSPACE}/out/*.wcp" > /dev/null; then
            gh release upload "${RELEASE_TAG}" "${GITHUB_WORKSPACE}/out/"*.wcp --repo "${REPO}" --clobber
          else
            echo "No new WCP files to upload."
          fi
