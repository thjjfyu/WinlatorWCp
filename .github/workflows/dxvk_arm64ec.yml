name: Build DXVK arm64ec rev4
#pinned. no fallback toolchain for now

on:
  workflow_dispatch:
  schedule:
    - cron: "0 18 * * *"

permissions:
  contents: write

defaults:
  run:
    shell: 'bash --noprofile --norc -Eeuo pipefail {0}'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  guard:
    name: Check Update
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      build: ${{ steps.decide.outputs.build }}
    steps:
      - name: Install jq, curl (minimal)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y --no-install-recommends jq curl ca-certificates

# ------------------------------------------------------------------------------ #

      - name: Get latest tag
        id: upstream
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -Eeuo pipefail
          API="https://api.github.com"
          OWNER="doitsujin"; REPO="dxvk"
          LATEST="$(curl -fsSL -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
                   "$API/repos/$OWNER/$REPO/releases/latest" | jq -r .tag_name)"
          if [[ -z "$LATEST" || "$LATEST" == "null" ]]; then
            LATEST="$(curl -fsSL -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
                     "$API/repos/$OWNER/$REPO/tags?per_page=100" \
                     | jq -r '.[].name' | grep -E '^v[0-9]+' | sort -V | tail -n1)"
          fi
          [[ -z "$LATEST" ]] && { echo "::error::No upstream tag found"; exit 1; }
          echo "tag=$LATEST" >> "$GITHUB_OUTPUT"

      - name: DXVK-arm64ec release?
        id: local
        env:
          GH_TOKEN: ${{ github.token }}
          REPO:     ${{ github.repository }}
        run: |
          set -Eeuo pipefail
          API="https://api.github.com/repos/${REPO}/releases/tags/DXVK-ARM64EC"
          HTTP="$(curl -s -o /tmp/rel.json -w '%{http_code}' \
                  -H "Authorization: Bearer ${GH_TOKEN}" \
                  -H "Accept: application/vnd.github+json" "$API" || true)"
          if [ "$HTTP" = "200" ]; then
            CUR="$(jq -r '.assets[].name' /tmp/rel.json \
              | sed -n -E 's/^(Patched_)?dxvk-arm64ec-([0-9]+\.[0-9]+(\.[0-9]+)?)\.wcp$/\2/p' \
              | sort -V | tail -n1)"
          else
            CUR=""
          fi
          echo "cur=${CUR}" >> "$GITHUB_OUTPUT"
          echo "Current: ${CUR:-<none>}"

      - name: Decide build
        id: decide
        run: |
          set -Eeuo pipefail
          UP="${{ steps.upstream.outputs.tag }}"
          CUR="${{ steps.local.outputs.cur }}"
          up_base="${UP#v}"
          if [[ -z "$CUR" ]]; then
            echo "build=true" >> "$GITHUB_OUTPUT"; exit 0
          fi
          if dpkg --compare-versions "$up_base" gt "$CUR"; then
            echo "build=true"  >> "$GITHUB_OUTPUT"
          else
            echo "build=false" >> "$GITHUB_OUTPUT"
          fi

# ------------------------------------------------------------------------------ #

  build-and-release:
    name: Build & release missing versions (arm64ec)
    needs: guard
    if: needs.guard.outputs.build == 'true'
    runs-on: ubuntu-24.04
    env:
      DXVK_REPO: doitsujin/dxvk
      PREFIX_EC: ${{ github.workspace }}/dist-arm64ec
      PREFIX_X86: ${{ github.workspace }}/dist-x86
      TOOLCHAIN_DIR: /opt/llvm-mingw
      RELEASE_TAG: DXVK-ARM64EC
      GH_TOKEN: ${{ github.token }}
    steps:
      - name: Install host tooling
        run: |
          sudo apt-get -yq update
          sudo apt-get -yq install --no-install-recommends \
            curl xz-utils jq ca-certificates \
            git meson ninja-build glslang-tools pkg-config \
            build-essential python3 zstd gh file

      - name: Ensure glslang (--vn)
        run: |
          set -Eeuo pipefail
          cat > /tmp/min.comp <<'GLSL'
          #version 450
          void main() {}
          GLSL
          have() { command -v "$1" >/dev/null 2>&1 || return 1; "$1" --quiet --target-env vulkan1.3 --vn testvar -o /tmp/min.h /tmp/min.comp; }
          if have glslang; then :
          elif have glslangValidator; then
            BIN="$HOME/.local/bin"; mkdir -p "$BIN"
            ln -sf "$(command -v glslangValidator)" "$BIN/glslang"
            echo "$BIN" >> "$GITHUB_PATH"
          else
            echo "::error::No glslang/glslangValidator with working --vn"; exit 1
          fi

      - name: Download pinned llvm-mingw (bylaws 20250305, UCRT, Ubuntu 20.04 x86_64)
        run: |
          set -Eeuo pipefail
          URL="https://github.com/bylaws/llvm-mingw/releases/download/20250305/llvm-mingw-20250305-ucrt-ubuntu-20.04-x86_64.tar.xz"
          sudo mkdir -p "$TOOLCHAIN_DIR"
          curl -fL --retry 3 --retry-delay 2 "$URL" -o /tmp/llvm-mingw.tar.xz
          sudo tar -C "$TOOLCHAIN_DIR" --strip-components=1 -xJf /tmp/llvm-mingw.tar.xz
          echo "$TOOLCHAIN_DIR/bin" >> "$GITHUB_PATH"
          export PATH="$TOOLCHAIN_DIR/bin:$PATH"   # ensure toolchain comes first

      - name: Sanity check toolchain triplets (no x64 fallback)
        run: |
          set -Eeuo pipefail
          export PATH="$TOOLCHAIN_DIR/bin:$PATH"
          must_have=(arm64ec-w64-mingw32-clang arm64ec-w64-mingw32-clang++ i686-w64-mingw32-clang i686-w64-mingw32-clang++)
          for bin in "${must_have[@]}"; do
            command -v "$bin" >/dev/null || { echo "::error::$bin not found in PATH"; exit 1; }
          done
          arm64ec_target="$(arm64ec-w64-mingw32-clang -v 2>&1 | sed -nE 's/^Target:\s*([[:alnum:]_-]+)$/\1/p' | head -n1)"
          i686_target="$(i686-w64-mingw32-clang -v 2>&1       | sed -nE 's/^Target:\s*([[:alnum:]_-]+)$/\1/p' | head -n1)"
          case "$arm64ec_target" in
            arm64ec-w64-mingw32|arm64ec-w64-windows-gnu) : ;;
            *) echo "::error::arm64ec CC target mismatch: $arm64ec_target"; exit 1 ;;
          esac
          case "$i686_target" in
            i686-w64-mingw32|i686-w64-windows-gnu) : ;;
            *) echo "::error::i686 CC target mismatch: $i686_target"; exit 1 ;;
          esac

          # expose for cross-file generation
          echo "TRIP_EC=$arm64ec_target" >> "$GITHUB_ENV"
          echo "TRIP_X86=$i686_target" >> "$GITHUB_ENV"
          case ":$PATH:" in
            *":$TOOLCHAIN_DIR/bin:"*) : ;;
            *) echo "::error::toolchain bin is not prefixed in PATH"; exit 1 ;;
          esac

      - name: Create Meson cross files (official arm64ec triplet + i686 WOW64)
        run: |
          set -Eeuo pipefail

          # arm64ec cross file (per arm64ec guidance)
          cat > "${{ github.workspace }}/arm64ec.cross" <<'EOF'
          [binaries]
          ar = 'arm64ec-w64-mingw32-ar'
          c = 'arm64ec-w64-mingw32-clang'
          cpp = 'arm64ec-w64-mingw32-clang++'
          windres = 'arm64ec-w64-mingw32-windres'
          strip = 'llvm-strip'
          widl = 'arm64ec-w64-mingw32-widl'
          pkgconfig = 'pkg-config'
          [host_machine]
          system = 'windows'
          cpu_family = 'aarch64'
          cpu = 'aarch64'
          endian = 'little'
          [properties]
          needs_exe_wrapper = true
          [built-in options]
          c_args = ['--target=arm64ec-w64-mingw32']
          cpp_args = ['--target=arm64ec-w64-mingw32']
          c_link_args = ['--target=arm64ec-w64-mingw32','-fuse-ld=lld']
          cpp_link_args = ['--target=arm64ec-w64-mingw32','-fuse-ld=lld']
          EOF

          # 32-bit i686 cross file (WOW64 side)
          cat > "${{ github.workspace }}/i686.cross" <<'EOF'
          [binaries]
          ar = 'i686-w64-mingw32-ar'
          c = 'i686-w64-mingw32-clang'
          cpp = 'i686-w64-mingw32-clang++'
          windres = 'i686-w64-mingw32-windres'
          strip = 'llvm-strip'
          pkgconfig = 'pkg-config'
          [host_machine]
          system = 'windows'
          cpu_family = 'x86'
          cpu = 'i686'
          endian = 'little'
          [properties]
          needs_exe_wrapper = true
          [built-in options]
          c_args = ['--target=i686-w64-mingw32']
          cpp_args = ['--target=i686-w64-mingw32']
          c_link_args = ['--target=i686-w64-mingw32','-fuse-ld=lld']
          cpp_link_args = ['--target=i686-w64-mingw32','-fuse-ld=lld']
          EOF

      - name: Clone DXVK
        run: |
          set -Eeuo pipefail
          git clone --recurse-submodules https://github.com/${DXVK_REPO}.git src
          cd src && git fetch --tags --force

      - name: Configure git identity
        run: |
          git -C src config user.name "DXVK Builder"
          git -C src config user.email "builder@users.noreply.github.com"

      - name: Resolve versions & compute NEW to build
        env:
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -Eeuo pipefail
          cd src
          git tag -l 'v*' \
            | { grep -E '^v[0-9]+\.[0-9]+(\.[0-9]+)?$' || true; } \
            | LC_ALL=C sort -V \
            | awk '
                function cmp(a,b,  i,A,B){split(a,A,".");split(b,B,".");
                  for(i=1;i<=3;i++){if((A[i]+0)<(B[i]+0))return -1;if((A[i]+0)>(B[i]+0))return 1}return 0}
                {ver=substr($0,2); if (cmp(ver,"2.3.1")>=0) print $0}
              ' > "${GITHUB_WORKSPACE}/versions.txt"

          : > "${GITHUB_WORKSPACE}/to_build.txt"
          
          EXIST="/tmp/exist.txt"; : > "$EXIST"
          if gh release view "${RELEASE_TAG}" --repo "${REPO}" >/dev/null 2>&1; then
            gh api repos/"${REPO}"/releases/tags/"${RELEASE_TAG}" \
              | jq -r '.assets[].name' \
              | sed -n -E 's/^(Patched_)?dxvk-arm64ec-([0-9]+\.[0-9]+(\.[0-9]+)?)\.wcp$/\2/p' \
              | LC_ALL=C sort -V > "$EXIST" || true
          fi

          while IFS= read -r tag; do
            [ -n "$tag" ] || continue
            base="${tag#v}"
            if ! grep -Fxq "$base" "$EXIST"; then
              echo "$tag $base" >> "${GITHUB_WORKSPACE}/to_build.txt"
            fi
          done < "${GITHUB_WORKSPACE}/versions.txt"

          echo "Candidates:";       cat "${GITHUB_WORKSPACE}/versions.txt" || true
          echo "Already uploaded:"; cat "$EXIST" || true
          echo "To build:";         cat "${GITHUB_WORKSPACE}/to_build.txt" || true

      - name: Preflight
        run: |
          set -Eeuo pipefail
          printf 'int main(void){return 0;}\n' > /tmp/t.c
          arm64ec-w64-mingw32-clang -v --target=arm64ec-w64-mingw32 /tmp/t.c -o /tmp/t-ec.exe -fuse-ld=lld
          i686-w64-mingw32-clang    -v --target=i686-w64-mingw32    /tmp/t.c -o /tmp/t-x86.exe -fuse-ld=lld
          file /tmp/t-ec.exe /tmp/t-x86.exe || true

      - name: Build NEW versions (arm64ec + i686)
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
        run: |
          set -Eeuo pipefail
          OUT="${GITHUB_WORKSPACE}/out"; mkdir -p "$OUT"
          cd "${GITHUB_WORKSPACE}/src"

          LIST="${GITHUB_WORKSPACE}/to_build.txt"
          if [[ ! -f "$LIST" || ! -s "$LIST" ]]; then
            echo "No new versions to build."; exit 0; fi

          while read -r tag base; do
            echo "::group::Build ${tag} (dxvk)"
            git checkout -f "$tag"
            git submodule update --init --recursive --checkout
            git clean -xdf
            git submodule update --init --recursive --checkout
            
            PATCH_A=0
            PATCH_B=0
            PATCH_MISC=0
            CHANGED=0
            # patches --------------------------------------------------------------- #
            # v2.5 UnmappedSubresource constexpr init issue -> safe cast
            TEX="src/d3d11/d3d11_texture.h"
            if [[ -f "$TEX" ]] && grep -qE '\\bUnmappedSubresource\\b' "$TEX"; then
              cp "$TEX" "${TEX}.bak"
              perl -0777 -pe \
                's/\bstatic\s+(?:const|constexpr)\s+D3D11_MAP\s+UnmappedSubresource\s*=\s*[^;]+;/inline static const D3D11_MAP UnmappedSubresource = static_cast<D3D11_MAP>(-1);/s' \
                -i "$TEX" && PATCH_A=1 && CHANGED=1
            fi
            
            # patches --------------------------------------------------------------- #
            # Newer mingw headers define _D3DDEVINFO_RESOURCEMANAGER -> drop DXVK duplicate if toolchain has it
            INC="src/d3d9/d3d9_include.h"
            TOOL_X64="/opt/llvm-mingw/arm64ec-w64-mingw32/include/d3d9types.h"
            TOOL_X86="/opt/llvm-mingw/i686-w64-mingw32/include/d3d9types.h"
            if [[ -f "$INC" ]] && (grep -Fq "_D3DDEVINFO_RESOURCEMANAGER" "$TOOL_X64" || grep -Fq "_D3DDEVINFO_RESOURCEMANAGER" "$TOOL_X86"); then
              if grep -qE 'typedef\s+struct\s+_D3DDEVINFO_RESOURCEMANAGER\b' "$INC"; then
                cp "$INC" "${INC}.bak"
                perl -0777 -pe 's/typedef\s+struct\s+_D3DDEVINFO_RESOURCEMANAGER\b.*?}\s*D3DDEVINFO_RESOURCEMANAGER\b[^;]*;//s' -i "$INC" && PATCH_B=1 && CHANGED=1
              fi
            fi
            
            # patches --------------------------------------------------------------- #
            # Mismatched-tags warning: align forward decl to 'struct' (optional)
            MEM="src/dxvk/dxvk_memory.h"
            if [[ -f "$MEM" ]] \
               && grep -qE '^[[:space:]]*class[[:space:]]+DxvkMemoryChunk;' "$MEM" \
               && grep -qE '^[[:space:]]*struct[[:space:]]+DxvkMemoryChunk[[:space:]]*\{' "$MEM"; then
              cp "$MEM" "${MEM}.bak2"
              sed -E -i 's/^[[:space:]]*class[[:space:]]+DxvkMemoryChunk;/struct DxvkMemoryChunk;/' "$MEM" && PATCH_MISC=1 && CHANGED=1
            fi

            ver="${tag#v}"

            # Clean Tags ------------------------------------------------------------ #
            HUD_TAG="${tag}-arm64ec"

            if [[ "$CHANGED" -eq 1 ]]; then
              git add -A
              git -c user.name="DXVK Builder" -c user.email="builder@noreply" \
                  commit -m "compat: minimal build fixes for ${tag}"
            fi

            git tag -f "${HUD_TAG}" -m "HUD tag for arm64ec: ${HUD_TAG}"

            git tag -d "${tag}" || true

            # Configure & build (64-bit arm64ec)
            meson setup "${GITHUB_WORKSPACE}/build.ec" --cross-file "${GITHUB_WORKSPACE}/arm64ec.cross" \
              --buildtype release --prefix "${PREFIX_EC}" \
              -Dbuild_id=false -Dstrip=true \
              || { cat "${GITHUB_WORKSPACE}/build.ec/meson-logs/meson-log.txt" || true; exit 1; }
            ninja -C "${GITHUB_WORKSPACE}/build.ec" -j"$(nproc)"
            meson install --no-rebuild -C "${GITHUB_WORKSPACE}/build.ec"

            # Configure & build (32-bit x86)
            meson setup "${GITHUB_WORKSPACE}/build.x86" --cross-file "${GITHUB_WORKSPACE}/i686.cross" \
              --buildtype release --prefix "${PREFIX_X86}" \
              -Dbuild_id=false -Dstrip=true \
              || { cat "${GITHUB_WORKSPACE}/build.x86/meson-logs/meson-log.txt" || true; exit 1; }
            ninja -C "${GITHUB_WORKSPACE}/build.x86" -j"$(nproc)"
            meson install --no-rebuild -C "${GITHUB_WORKSPACE}/build.x86"

            # Verify Meson machine assignments ------------------------------------- #
            meson introspect "${GITHUB_WORKSPACE}/build.ec"  --machine > /tmp/m_ec.json
            meson introspect "${GITHUB_WORKSPACE}/build.x86" --machine > /tmp/m_x86.json
            jq -e '.host.system == "windows" and .host.cpu == "aarch64"' /tmp/m_ec.json > /dev/null \
              || { echo "::error::build.ec host machine must be windows/aarch64"; cat /tmp/m_ec.json; exit 1; }
            jq -e '.host.system == "windows" and (.host.cpu == "x86" or .host.cpu == "i686")' /tmp/m_x86.json > /dev/null \
              || { echo "::error::build.x86 host machine must be windows/x86(i686)"; cat /tmp/m_x86.json; exit 1; }

            # Collect DLLs (system32 = arm64ec, syswow64 = i686)
            mkdir -p "${GITHUB_WORKSPACE}/DXVK_WCP/system32" "${GITHUB_WORKSPACE}/DXVK_WCP/syswow64"
            cp -v "${PREFIX_EC}/bin/"*.dll  "${GITHUB_WORKSPACE}/DXVK_WCP/system32/" || true
            cp -v "${PREFIX_X86}/bin/"*.dll "${GITHUB_WORKSPACE}/DXVK_WCP/syswow64/" || true

            # Verify COFF machine types -------------------------------------------- #
            shopt -s nullglob
            check_machine() {
              local want="$1"; shift
              local files=( "$@" )
              [ ${#files[@]} -gt 0 ] || { echo "::error::no files to check for $want"; exit 1; }
              for f in "${files[@]}"; do
                llvm-readobj --file-headers "$f" | grep -Ei "Machine:\s*$want" >/dev/null \
                  || { echo "::error::Unexpected machine for $f (want=$want)"; llvm-readobj --file-headers "$f" | sed -n '1,40p'; exit 1; }
              done
            }
            check_machine ARM64EC "${PREFIX_EC}/bin/"*.dll
            check_machine I386    "${PREFIX_X86}/bin/"*.dll

            # Collect file lists and generate profile.json  -------------------------- #
            (cd "${GITHUB_WORKSPACE}/DXVK_WCP" && find system32 -maxdepth 1 -type f -name '*.dll' -printf '%f\n' | LC_ALL=C sort) > /tmp/x64.txt || true
            (cd "${GITHUB_WORKSPACE}/DXVK_WCP" && find syswow64 -maxdepth 1 -type f -name '*.dll' -printf '%f\n' | LC_ALL=C sort) > /tmp/x86.txt || true
            if [[ ! -s /tmp/x64.txt && ! -s /tmp/x86.txt ]]; then
              echo "::error::No DLLs discovered for ${base}"; exit 1; fi
            jq -R -s 'split("\n") | map(select(length>0))' /tmp/x64.txt  > /tmp/x64.json
            jq -R -s 'split("\n") | map(select(length>0))' /tmp/x86.txt  > /tmp/x86.json

            # Create profile.json
            jq -n --arg VN "arm64ec-${base}" --argjson VC 0 --arg DESC "DXVK arm64ec build by Ari" \
                  --arg SYS '${system32}/' --arg WOW '${syswow64}/' \
                  --slurpfile x64 /tmp/x64.json --slurpfile x86 /tmp/x86.json '
              ($x64[0] // []) as $A | ($x86[0] // []) as $B |
              { type:"DXVK", versionName:$VN, versionCode:$VC, description:$DESC,
                files: [ ($A[]? | {source:("system32/"+. ), target:($SYS+.)}),
                         ($B[]? | {source:("syswow64/"+. ), target:($WOW+.)}) ] }' \
              > "${GITHUB_WORKSPACE}/DXVK_WCP/profile.json"

            # Verify packaged layout (system32=ARM64EC, syswow64=I386) -------------- #
            for f in "${GITHUB_WORKSPACE}/DXVK_WCP/system32/"*.dll; do
              llvm-readobj --file-headers "$f" | grep -qi "Machine:\s*ARM64EC" \
                || { echo "::error::system32 contains non-ARM64EC: $f"; exit 1; }
            done
            for f in "${GITHUB_WORKSPACE}/DXVK_WCP/syswow64/"*.dll; do
              llvm-readobj --file-headers "$f" | grep -qi "Machine:\s*I386" \
                || { echo "::error::syswow64 contains non-I386: $f"; exit 1; }
            done

            # Decide output filename (rename when patch A or B applied) ------------- #
            WCP_BASE="dxvk-arm64ec-${base}.wcp"
            OUT_NAME="$WCP_BASE"
            if [[ $PATCH_A -eq 1 || $PATCH_B -eq 1 ]]; then
              OUT_NAME="Patched_${WCP_BASE}"
            fi

            # Pack WCP
            tar -C "${GITHUB_WORKSPACE}/DXVK_WCP" --zstd --format=gnu --owner=0 --group=0 --numeric-owner \
              --sort=name \
              -cf "${OUT}/${OUT_NAME}" profile.json system32 syswow64
            echo "::endgroup::"
          done < "$LIST"

      - name: Build release notes (minimal)
        run: |
          set -Eeuo pipefail
          NOTES="${GITHUB_WORKSPACE}/RELEASE_NOTES.md"
          printf 'ðŸ¤– Automated arm64ec builds (2.3.1+)\n\n' > "$NOTES"
          if compgen -G "${GITHUB_WORKSPACE}/out/*.wcp" > /dev/null; then
            latest="$(ls -1 "${GITHUB_WORKSPACE}/out"/*.wcp | sed -n -E 's#.*/(Patched_)?dxvk-arm64ec-([0-9]+\.[0-9]+(\.[0-9]+)?)\.wcp#\2#p' | LC_ALL=C sort -V | tail -n1)"
            ver="$latest"
            if [[ -n "$ver" ]]; then
              echo "Current: ${ver}" >> "$NOTES"
            fi
          fi
          cat "$NOTES"

      - name: Create/Update GitHub Release (DXVK-ARM64EC) + upload WCPs
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        run: |
          set -Eeuo pipefail
          NOTES="${GITHUB_WORKSPACE}/RELEASE_NOTES.md"
          RELEASE_TAG="DXVK-ARM64EC"

          if ! gh release view "${RELEASE_TAG}" --repo "${REPO}" >/dev/null 2>&1; then
            gh release create "${RELEASE_TAG}" --repo "${REPO}" -t "${RELEASE_TAG}" -F "$NOTES"
          else
            gh release edit   "${RELEASE_TAG}" --repo "${REPO}" -t "${RELEASE_TAG}" -F "$NOTES"
          fi

          if compgen -G "${GITHUB_WORKSPACE}/out/*.wcp" > /dev/null; then
            gh release upload "${RELEASE_TAG}" "${GITHUB_WORKSPACE}/out/"*.wcp --repo "${REPO}" --clobber
          else
            echo "No new WCP files to upload."
          fi
